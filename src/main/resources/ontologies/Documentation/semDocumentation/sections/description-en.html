<html>
<h2 id="desc" class="list">SEM: Description <span class="backlink"> </span></h2>
<span class="markdown">
        In this section we describe how these modeling decisions are implemented in SEM. First we discuss the core classes and the properties that make up SEM; then how to model views, roles and temporary validity as constraints on properties; and ﬁnally how to model time and space with symbols (c.q. URIs) or values (c.q. coordinates). We give a simple and more elaborate example of how an event from the historical domain can be modeled in SEM. These examples represent information from the following sentence, 4 which represents a typical sentence from the historical domain:

        The Dutch launched the ﬁrst police action in the Dutch East Indies in 1947; the Dutch presented themselves as liberators but were seen as occupiers by the Indonesian people.
        
        This example is interesting for a number of reasons: (1) it contains conﬂicting views on the role of the actor: were the Dutch liberators or occupiers? (2) it makes explicit according to which authority the roles hold (the Dutch/Indonesian people); (3) it presents a challenge for modeling the type of the place involved: the Dutch East Indies were at that time an independent Republic according to the Indonesians, but were a ‘‘controlled region’’ according to the Dutch. The next subsections describe the classes, properties and constraints of SEM.
        
        
        
        
        SEM’s classes are divided in three groups: core classes, types, and constraints. There are four core classes: sem:Event (what happens), sem:Actor (who or what participated), sem:Place (where), sem:Time (when). Each core class 5 has an associated sem:Type class, which contains resources that indicate the type of a core individual. Individuals and their types are usually borrowed from other vocabularies. For example, the sem:Place ‘‘Indonesia’’ (tgn:1000116) and its sem:PlaceType ‘‘republic’’ (tgn:82171) are borrowed from the Getty Institute’s Thesaurus of Geographical Names (TGN). 6
        
        The sem:Type classes exist to aggregate the various implementations of type systems in any vocabulary. Some vocabularies do not have properties that exactly correspond to the sem:type property, even though type can be derived from the value of other properties. This can be done by using Alan Rector’s Value Sets and Value Partition patterns. 7 Having explicit sem:Type classes provides a placeholder to deﬁne these patterns. An example of Rector’s pattens applied to SEM can be found in Section 2 of [9]. Also, having an explicit sem:Type class makes it easier to deﬁne applications like facet browsers on top of SEM. You can simply deﬁne your interface to show all sem:Type instances, instead of having to query for all top classes from the domain vocabularies. 
        

        
        Property constraints can be applied to any property. They constrain the validity of the property and are expressed as either a reiﬁcation of the property or by adding attributes to the property and turning it into an n-ary relation. There are three permissible ways to represent sem:Constraints. The default representation is the rdf:value pattern, which is often used when representing the unit of measure of a value. 9 There are three kinds of sem:Constraints: sem:Role, sem:Temporary and sem:View. sem:Role deﬁnes the role that an individual of a class is playing in the context of a speciﬁc event (i.e. to which it is linked with a sem:eventProperty). Roles can be speciﬁed for all sem:Core individuals, for example, Actors (‘‘occupier’’) as well as places (‘‘capital city’’, dbpedia:Colony). It is not meant to model roles in the sense of dependent types, like ‘‘mother’’, or temporary types. The latter can be done by putting a sem:Temporary constraint on a sem:type property. Instead, sem:Role explicitly models the eventbounded role: an ‘‘occupier’’, ‘‘liberator’’, ‘‘landing area’’. These roles do not depend on external conditions (like the fact to have a child deﬁnes a ‘‘mother’’), but only on the way they are related to the ongoing sem:Event. sem:Temporary deﬁnes the temporal boundary within which a property holds, for example, the type of the Place ‘‘Indonesia’’ as a ‘‘republic’’ holds from 1945 on, at least according to the Indonesians. This notion can be modeled with sem:View, which is used to deﬁne points of view and opinions. Indonesia, in 1947, has either the type ‘‘republic’’ or ‘‘controlled region’’, depending on the source of information. This is modeled as a sem:View constraint on the property (sem:placeType in this case) that holds sem:accordingTo a sem:Authority (in the case of the example, respectively the Indonesian People or the Netherlands). The class sem:Authority is used to indicate according to whom a statement is valid. Individuals of sem:Authority can be, but are not necessarily sem:Actors. They can also symbolize data sources. The sem:Authority class is meant as a hook for provenance and trust reasoning, even though SEM itself does not explicitly provide this.

Multiple kinds of sem:Constraints can be used in combination to create conjunctive statements. An example of the former is the blank node to the right of ex:FirstPoliceAction that stands for the constrained sem:hasActor property. This represents both a sem:Role and a sem:View. This expresses the fact that according to both authorities the actor is dbpedia:Netherlands, but they differ on which sem:roleType it has. This is expressed with the latter type of combination, by chaining constraints. The sem:roleType property of the sem:Role constraint is constrained further with a sem:View constraint. The API, which will be discussed in Section 3, automatically processes constraints. Modeling the case where one actor plays different roles in two different events can be accomplished by having two separate blank nodes indicating the different roles that both point to the same URI indicating the actor with the rdf:value property. 


SEM’s properties are divided in three kinds: sem:eventProperty, sem:type properties and a few miscellaneous properties like sem:accordingTo and sem:hasTimeStamp’s subproperties. The sem:eventProperty relates sem:Events to other individuals. A sem:type relates individuals of the sem:Core class 10 to individuals of sem:Type. There are speciﬁc subproperties of sem:type for each of the core classes, for example sem:eventType, to facilitate querying. This reduces the strain on reasoners, because the property points directly to an individual of sem:EventType without doing any subsumption reasoning. sem:accordingTo relates a sem:View to a sem:Authority and is used to represent opinions.

There are two aggregation relations among the sem:eventProperty and sem:type properties: sem:hasSubEvent and sem:hasSubType. These can be used to indicate that respectively a sem:Event or sem:Type is related to another more generic sem:Event or sem:Type, without any further commitments. We decided not to model subtypes as subproperties of skos:broader/narrower, because we do not want to inherit the disjointness of skos:broader with skos:related. More speciﬁc relations between events and types are not part of SEM and should be taken from other ontologies, like GEM [14].

There are seven sem:hasTimeStamp properties. One for single time values, sem:hasTimeStamp; two for time intervals, sem:hasBeginTimeStamp and sem:hasEndTimeStamp; and four for uncertain time intervals, sem:hasEarliestBeginTimeStamp, sem:hasLatestBeginTimeStamp, sem:hasEarliestEndTimeStamp, and sem:hasLatestEndTimeStamp. The latter kind of intervals is used to describe any kind of uncertainty about the begin or end of a period. It does not imply, for example, a fuzzy interpretation of time. Open-ended intervals can be expressed by omitting begin or end timestamps.
</html>
